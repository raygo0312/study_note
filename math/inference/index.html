<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>推論 | study_note</title>
  <meta name="author" content="raygo">
  <link rel="stylesheet" href="../../lib/css/bootstrap-reboot.css">
  <link rel="stylesheet" href="../../lib/css/style.css">
  <script type="text/javascript" src="../../lib/js/mathjax_config.js" Defer></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" Defer></script>
</head>

<body>
  <header>
    <h1>推論</h1>
    <a href="../../">ホーム</a> -&gt; <a href="../">数学</a> -&gt; 推論
  </header>
  <main>
    <div class="you">
      まだ証明論の議論をするのに言葉が足りないからここでいくつかの言葉を定義するね
    </div>
    <h2>定義</h2>
    <p>
      以前に定義の定義をしたが，数学を形式化するためには定義の形式化も必要である．そこで，次の表現を用いる．
    </p>
    <dl>
      <h4>定義</h4>
      論理式$A,B$について，
      <dt>$A$を$B$で定義する</dt>
      <dd>$$A\Def B$$</dd>
      項$a,b$について，
      <dt>$a$を$b$で定義する</dt>
      <dd>$$a\def b$$</dd>
    </dl>
    <p>
      と表し，それぞれ次の述語と同じ扱いができるとする．
    </p>
    <dl>
      <h4>定義</h4>
      論理式$A,B$について，
      <dt>$A$と$B$は等価である</dt>
      <dd>$$A\Iff B$$</dd>
      項$a,b$について，
      <dt>$a$と$b$は恒等である</dt>
      <dd>$$a=b$$</dd>
    </dl>
    <div class="me">
      同じ扱いができるならこの表記いらなくない？
    </div>
    <div class="you">
      定義で論理を破綻しないための条件を覚えてる？<br>
      循環定義はダメだったね<br>
      でも，等価である分には，自己言及は許されてる<br>
      これを区別するために，表現も分けられてる
    </div>
    <p>
      <ruby><dfn>等価</dfn>
        <rt>equivalence</rt>
      </ruby>や<ruby><dfn>恒等</dfn>
        <rt>equality</rt>
      </ruby>であることを<ruby><dfn>等しい</dfn>
        <rt>equal</rt>
      </ruby>ともいう．等価や恒等である関係を<ruby><dfn>相等関係</dfn>
        <rt>equality relation</rt>
      </ruby>といい，相等関係が満たすべき性質を<ruby><dfn>等価性</dfn>
        <rt>equivalence</rt>
      </ruby>という．等価性については今後述べる．
    </p>
    <div class="you">
      等価は普通同値って言われるけど，同値関係で使われる同値と区別するためにあえて別の言い方をしたよ
    </div>
    <div class="me">
      等価と恒等って何が違うの？
    </div>
    <div class="you">
      本質は同じだよ<br>
      論理としての値と，項としての値が等しいことを区別して言い分けてるよ
    </div>
    <h2>一階述語論理で使われる文字</h2>
    <h3>真理関数</h3>
    <p>
      命題論理や一階述語論理で一般に定義される真理関数を用意する．用意する真理関数は<ruby><dfn>否定</dfn>
        <rt>negation</rt>
      </ruby>，<ruby><dfn>連言</dfn>
        <rt>conjunction</rt>
      </ruby>，<ruby><dfn>選言</dfn>
        <rt>disjunction</rt>
      </ruby>，<ruby><dfn>含意</dfn>
        <rt>implication</rt>
      </ruby>である．
    </p>
    <dl>
      <h4>用意</h4>
      論理式$A,B$について，
      <dt>否定</dt>
      <dd>$$\lnot\p{A}$$</dd>
      <dt>連言</dt>
      <dd>$$\land\p{A,B}$$</dd>
      <dt>選言</dt>
      <dd>$$\lor\p{A,B}$$</dd>
      <dt>含意</dt>
      <dd>$$\to\p{A,B}$$</dd>
    </dl>
    <p>
      形式化する上では論理体系の意味を考えないが，意味がわからないと理解しづらいと思うので，参考までに自然言語としての意味を載せる．直感でわかりやすいように，真理関数は自然言語でよくつかわれる言葉が元になっている．
    </p>
    <aside>
      <h4>真理関数の意味</h4>
      論理式$A,B$について，
      <ul>
        <li>否定$\lnot\p{A}$ : $A$ではない</li>
        <li>連言$\land\p{A,B}$ : $A$かつ$B$</li>
        <li>選言$\lor\p{A,B}$ : $A$または$B$</li>
        <li>含意$\to\p{A,B}$ : $A$ならば$B$</li>
      </ul>
    </aside>
    <p>
      このままでは扱いづらいので，真理関数を演算子として扱いたい．このとき，<ruby><dfn>論理演算子</dfn>
        <rt>logical operation</rt>
      </ruby>ともいう．次のように表す．
    </p>
    <dl>
      <h4>定義</h4>
      論理式$A,B$について，
      <dt>$\lnot$演算子</dt>
      <dd>$$\p{\lnot A}\Def\lnot\p{A}$$</dd>
      <dt>$\lor$演算子</dt>
      <dd>$$\p{A\land B}\Def\land\p{A,B}$$</dd>
      <dt>$\land$演算子</dt>
      <dd>$$\p{A\lor B}\Def\lor\p{A,B}$$</dd>
      <dt>$\to$演算子</dt>
      <dd>$$\p{A\to B}\Def\to\p{A,B}$$</dd>
    </dl>
    <p>
      二項演算子におけるこの記法を<ruby><dfn>中置記法</dfn>
        <rt>infix notation</rt>
      </ruby>という．一方，前に置く記法を<ruby><dfn>前置記法</dfn>
        <rt>prefix notation</rt>
      </ruby>(<ruby><dfn>ポーランド記法</dfn>
        <rt>porlish notation</rt>
      </ruby>)という．後ろに置く記法を<ruby><dfn>後置記法</dfn>
        <rt>postfix notation</rt>
      </ruby>(<ruby><dfn>逆ポーランド記法</dfn>
        <rt>reverse polish notation</rt>
      </ruby>)という．便利なのでこれらのほかにもう2つ演算子を定義する．
    </p>
    <dl>
      <h4>定義</h4>
      論理式$A,B$について，
      <dt>等価</dt>
      <dd>
        $$\p{A\iff B}\Def\p{\p{A\to B}\land\p{B\to A}}$$
      </dd>
      <dt>排他的論理和</dt>
      <dd>
        $$\p{A\veebar B}\Def\p{A\land\p{\lnot B}\lor\p{\p{\lnot A}\landB}}$$
      </dd>
    </dl>
    <p>
      <ruby><dfn>排他的論理和</dfn>
        <rt>exclusive disjunction</rt>
      </ruby>はどちらか一方のみであるという意味である．
    </p>
    <div class="me">
      また等価！？<br>
      同じ言葉だけど文字がちょっと違う
    </div>
    <div class="you">
      どっちも本質的には同じなんだけどね<br>
      $\Iff$は推論の意味で論理式の関係を表していて，どっちからでも推論可能であることを示してるよ<br>
      $\iff$は論理式の文字で，対称であることを示してるよ<br>
    </div>

    <h3>量化子</h3>
    <aside>
      <h4>例題</h4>
      二次関数$f\p{x}=ax^2+bx+c$が次の条件を満たす$a,b,c$の必要十分条件を求めよ．
      <ol>
        <li>すべての$x$で$f\p{x}\gt0$を満たす．</li>
        <li>$f\p{x}\gt0$を満たす$x$が存在する．</li>
      </ol>
    </aside>
    <div class="me">
      数学でこんな問題が出てきたんだけど<br>
      すべてと存在の違いって何？条件もよくわからない……
    </div>
    <div class="you">
      前に量化という表現を導入したよね<br>
      それに関係してるよ
    </div>
    <p>
      2つの量化表現を導入する．<ruby><dfn>全称量化子</dfn>
        <rt>universal quantifier</rt>
      </ruby>と<ruby><dfn>全称量化子</dfn>
        <rt>universal quantifier</rt>
      </ruby>である．
    </p>
    <dl>
      <h4>定義</h4>
      <dt>全称量化子</dt>
      <dd>$$\forall$$</dd>
      <dt>存在量化子</dt>
      <dd>
        $$\exists$$
      </dd>
    </dl>
    <p>
      具体的には，論理式$F$に対して「すべての$x$について$F\p{x}$である」を$\forall
      x\p{F\p{x}}$と表し，<ruby><dfn>全称量化</dfn>
        <rt>universal quantification</rt>
      </ruby>という．また，「$F\p{x}$となる$x$が存在する」を$\exists
      x\p{F\p{x}}$と表し，<ruby><dfn>存在量化</dfn>
        <rt>existential quantification</rt>
      </ruby>という．
    </p>
    <div class="me">
      さっきの問題は，
      <ol>
        <li>$\forall x\p{f\p{x}\gt0}$</li>
        <li>$\exists x\p{f\p{x}\gt0}$</li>
      </ol>
      って表せるね
    </div>

    <h3>項と述語</h3>
    <p>
      項は集合のみとする．述語には$\in$と$=$を用いる．述語を演算子として扱うとき，<ruby><dfn>関係演算子</dfn>
        <rt>relational operator</rt>
      </ruby>という．これも論理演算子と同様に中置記法で表す．詳しくは集合論で扱う．
    </p>

    <h2>略記</h2>
    <h3>演算子の優先順位</h3>
    <p>
      論理演算子を用いると，「$P$でないかつ$Q$のときのみ$P$ならば$P$または$Q$である」という曖昧で複雑な命題に対しても$\p{\p{\p{\lnot P}\land Q}\iff
      P}\to\p{P\lor
      Q}$と命題同士の関係を明確に記述することが出来る．しかし，括弧が冗長で式が煩雑である．そこで，演算子に<ruby><dfn>優先順位</dfn>
        <rt>precedence</rt>
      </ruby>を定める．演算子の優先順位とは括弧がない場合に優先して計算される順番のことである．<ruby><dfn>右結合</dfn>
        <rt>right-associative</rt>
      </ruby>は優先順位が同じ時に，右側の演算子を優先することである．左側の場合は<ruby><dfn>左結合</dfn>
        <rt>left-associative</rt>
      </ruby>である．
    </p>
    <dl>
      <h4>定義</h4>
      論理式$A$について，
      <dt>二重括弧の省略</dt>
      <dd>$$\p{A}\Def\p{\p{A}}$$</dd>
      <dt>全体括弧の省略</dt>
      <dd>$$A\Def\p{A}$$</dd>
      $a,b,c$の演算子$\rho_1$が$\rho_2$より優先順位が高いとき，
      <dt>優先順位</dt>
      <dd>$$a\,\rho_1\,b\,\rho_2\,c\Def\p{a\,\rho_1\,b}\,\rho_2\,c$$</dd>
      $a,b,c$の演算子$\rho_1$と$\rho_2$の優先順位が同じで左結合であるとき，
      <dt>左結合</dt>
      <dd>$$a\,\rho_1\,b\,\rho_2\,c\Def\p{a\,\rho_1\,b}\,\rho_2\,c$$</dd>
      $a,b,c$の演算子$\rho_1$と$\rho_2$の優先順位が同じで右結合であるとき，
      <dt>右結合</dt>
      <dd>$$a\,\rho_1\,b\,\rho_2\,c\Def a\,\rho_1\,(b\,\rho_2\,c)$$</dd>
    </dl>
    <div class="you">
      ここでいう論理式は最長一致であることに注意してね<br>
      つまり，$A\Def\p{A}$をつかって，次のように変形するのはダメだよ<br>
      $$a\land\p{b\lor c}\Iff a\land b\lor c$$
    </div>
    <p>
      実際に使われる論理演算子の優先順位を定める．
    </p>
    <dl>
      <h4>定義</h4>
      上から順に優先順位が高いとする．また，特に明記しない限り演算子は右結合とする．
      <ul>
        <li>$\lnot$</li>
        <li>$\veebar$</li>
        <li>$\land$</li>
        <li>$\lor$</li>
        <li>$\to$</li>
        <li>$\iff$</li>
      </ul>
    </dl>
    <p>
      また，各種演算子ごとの大まかな優先順位も定める．推論文字($\To,\Iff,\sequent,\models$)の優先順位は最下位とする，算術演算とは($+,-,\cup$など)数字や集合など同士の演算子である．
    </p>
    <dl>
      <h4>定義</h4>
      上から順に優先順位が高いとする．
      <ul>
        <li>算術演算子</li>
        <li>関係演算子</li>
        <li>論理演算子</li>
      </ul>
    </dl>
    <aside>
      <h4>優先順位の例</h4>
      命題$P,Q,R$について，
      <ul>
        $$\lnot P\land Q\Iff\p{\lnot P}\land Q$$
        $$P\land Q\lor Q\land R\Iff\p{P\land Q}\lor\p{Q\land R}$$
        $$\lnot\lnot P\Iff\lnot\p{\lnot P}$$
        $$P\lor Q\lor R\Iff\p{P\lor Q}\lor R$$
        $$P\to Q\to R\Iff P\to\p{Q\to R}$$
        $$\lnot\p{P\lor Q}\land R\Iff\p{\lnot\p{P\lor Q}}\land R$$
      </ul>
    </aside>
    <details>
      <summary>練習問題1</summary>
      <p>
        次の括弧が省略された命題に括弧をつけろ．ただし，式全体の括弧は省略してよい．
      </p>
      <ol>
        <li>$\lnot P\land Q$</li>
        <li>$P\land Q\lor R\to P\lor\lnot Q\land R$</li>
        <li>$P\to Q\to P\iff Q$</li>
      </ol>
      <details class="sub">
        <summary>解答</summary>
        <p>
          優先順位が高い演算子から括弧をくくる．同順位の場合は右結合なら右側から，左結合なら左結合がから順に括弧をくくる．
        </p>
        <ol>
          <li>$\p{\lnot P}\land Q$</li>
          <li>$\p{\p{P\land Q}\lor R}\to\p{P\lor\p{\p{\lnot Q}\land R}}$</li>
          <li>$\p{P\to \p{Q\to P}}\iff Q$</li>
        </ol>
      </details>
    </details>
    <details>
      <summary>練習問題2</summary>
      <p>
        次の式が命題論理における論理式であることを示せ．ただし，$P,Q$は原子命題とする．
      </p>
      <ol>
        <li>$P\to P$</li>
        <li>$\lnot P\land Q$</li>
        <li>$P\iff P$</li>
      </ol>
      <details class="sub">
        <summary>解答</summary>
        <p>
          定義通り順に確認していけばよい．
        </p>
        <ol>
          <li>
            与式を変形する．
            \begin{align*}
            &P\to P\\
            \Iff&\to\p{P,P}\\
            \end{align*}
            よって，$P$は原子命題より$P$は論理式である．$\to$は二項真理関数で$P$は論理式より$\to\p{P,P}$は論理式である．したがって，$P\to P$は論理式である．
          </li>
          <li>
            与式を変形する．
            \begin{align*}
            &\lnot P\land Q\\
            \Iff&\p{\p{\lnot P}\land Q}\\
            \Iff&\land\p{\lnot\p{P},Q}\\
            \end{align*}
            よって，$P$は原子命題より$P$は論理式である．$\lnot$は1項真理関数で$P$は論理式より$\lnot\p{P}$は論理式である．また，$Q$は原子命題より$Q$は論理式である．よって，$\land$は2項真理関数で$\lnot\p{P}$と$Q$は論理式より$\land\p{\lnot\p{P},Q}$は論理式である．したがって，$\lnot
            P\land Q$は論理式である．
          </li>
          <li>
            与式を変形する．
            \begin{align*}
            &P\iff P\\
            \Iff&\p{P\to P}\land\p{P\to P}\\
            \Iff&\land\p{P\to P,P\to P}\\
            \end{align*}
            (1)より$P\to P$は論理式である．$\land$は2項真理関数で$P\to P$は論理式より$\land\p{P\to P,P\to
            P}$は論理式である．したがって，$P\iff P$は論理式である．
          </li>
        </ol>
      </details>
    </details>

    <h3>量化子の略記</h3>
    <p>
      量化子は適用範囲を決める必要があり，その範囲を括弧で囲わなければならない．しかし，変項が増えると括弧が煩雑になってしまうため，省略を考える．他にも便利な記法として次のものを定める．
    </p>
    <dl>
      <h4>定義</h4>
      量化子$\lambda,\lambda'$について，
      <dt>適用範囲の略記</dt>
      <dd>$$\lambda x,A\Def\lambda x\p{A}$$</dd>
      <dt>量化列挙の略記</dt>
      <dd>$$\lambda x\lambda' y,A\Def\lambda x,\lambda' y,A$$</dd>
      <dt>同量化の略記</dt>
      <dd>$$\lambda xy,A\Def\lambda x\lambda y,A$$</dd>
      <dt>量化子の別記</dt>
      <dd>$$^\lambda x,A\Def\lambda x,A$$</dd>
      論理式$A$，$1$項述語$F\p{x}$，項$x,y$について，
      <dt>$\forall$の条件の略記</dt>
      <dd>$$\forall F\p{x},A\Def\forall x,F\p{x}\to A$$</dd>
      <dt>$\exists$の条件の略記</dt>
      <dd>$$\exists F\p{x},A\Def\exists xA\land F\p{x}$$</dd>
      <dt>唯一存在量化子</dt>
      <dd>$$\exists! F\p{x}\Def\exists F\p{x}\land\forall
        F\p{x}\forall F\p{y}\p{x=y}$$</dd>
    </dl>

    <h3>否定の略記</h3>
    <p>
      否定した命題や述語はよく使われる．そのたびに，先頭に$\lnot$をつけて括弧でくくっていては，冗長的で認識しづらい．量化子や関係演算子に斜線を入れることで否定を表現する．
    </p>
    <dl>
      <h4>定義</h4>
      量化子$\lambda$，変数$x,y$の関係演算子$\rho$について，
      <dt>量化子の否定</dt>
      <dd>$$\cancel{\lambda} x,A\Def\lnot\p{\lambda x,A}$$</dd>
      <dt>関係演算子の否定</dt>
      <dd>$$x\,\cancel{\rho}\,y\Def\lnot\p{x\,\rho\,y}$$</dd>
    </dl>

    <h3>反転の略記</h3>
    <p>
      向きがある関係を表す演算子は表現力を上げるために逆向きで書くことがある．
    </p>
    <dl>
      <h4>定義</h4>
      関係演算子$\prec$に対して，
      <dt>反転記法</dt>
      <dd>$$B\succ A\Def A\prec B$$</dd>
    </dl>

    <h2>命題の表現</h2>
    <p>
      $A\to B$は重要な命題である．この命題が真であるとき，$B$を$A$に対して<ruby><dfn>必要条件</dfn>
        <rt>necessary condition</rt>
      </ruby>，$A$を$B$に対して<ruby><dfn>十分条件</dfn>
        <rt>sufficient condition</rt>
      </ruby>という．必要条件であり十分条件であるとき<ruby><dfn>必要十分条件</dfn>
        <rt>necessary and sufficient condition</rt>
      </ruby>という．また，この命題の<ruby><dfn>逆</dfn>
        <rt>converse</rt>
      </ruby>とは$B\to A$のことであり，<ruby><dfn>裏</dfn>
        <rt>inverse</rt>
      </ruby>とは$\lnot A\to\lnot B$のことであり，<ruby><dfn>対偶</dfn>
        <rt>contraposition</rt>
      </ruby>とは$\lnot B\to\lnot A$のことである．
    </p>
    <aside>
      <h4>命題で表す文</h4>
      <ul>
        <li>$\term{命題}$が成り立つ：$\term{命題}$は真である</li>
        <li>$\term{条件1}$が$\term{条件2}$から従う：$\term{条件2}$ならば$\term{条件1}$である</li>
        <li>$\term{条件1}$が$\term{条件2}$から導かれる：$\term{条件2}$ならば$\term{条件1}$である</li>
        <li>$\term{条件1}$従って$\term{条件2}$：$\term{条件1}$ならば$\term{条件2}$</li>
        <li>$\term{条件1}$よって$\term{条件2}$：$\term{条件1}$ならば$\term{条件2}$</li>
        <li>$\term{条件1}$故に$\term{条件2}$：$\term{条件1}$ならば$\term{条件2}$</li>
        <li>$\term{条件1}$が成り立つためには，$\term{条件2}$が必要：$\term{条件2}$は$\term{条件1}$の必要条件</li>
        <li>$\term{条件1}$が成り立つためには，$\term{条件2}$は十分：$\term{条件2}$は$\term{条件1}$の十分条件</li>
        <li>$\term{条件1}$なぜなら$\term{条件2}$から：$\term{条件1}$の必要条件は$\term{条件2}$である</li>
        <li>$\term{条件}$のための条件：$\term{条件}$の必要十分条件</li>
        <li>$\term{条件}$のとき：$\term{条件}$を前提として</li>
        <li>$\term{条件}$のときに限り：$\term{条件}$の必要十分条件</li>
        <li>任意の$\term{変数}$について：すべての$\term{変数}$について</li>
        <li>$\term{変数}$で：$\term{変数}$について</li>
        <li>$\term{変数}$に対して：$\term{変数}$について</li>
        <li>$\term{変数}$に関して：$\term{変数}$について</li>
        <li>$\term{変数}$で$\term{条件}$を満たす：$\term{変数}$で$\term{条件}$が真である</li>
        <li>$\term{変数}$で$\term{条件}$とは限らない：$\term{変数}$で$\term{条件}$が偽である$\term{変数}$が存在する</li>
      </ul>
    </aside>

    <h2>推論</h2>
    <h3>演繹と帰納</h3>
    <p>
      <ruby><dfn>推論</dfn>
        <rt>inference</rt>
      </ruby>とは論理的に説明することである．もうすこし具体的にいうと，<ruby><dfn>前提</dfn>
        <rt>premise</rt>
      </ruby>から<ruby><dfn>結論</dfn>
        <rt>conclusion</rt>
      </ruby>を論理的に導くことである．推論には大きく2つに分かれており，演繹と帰納である．<ruby><dfn>演繹</dfn>
        <rt>deduction</rt>
      </ruby>は前提を仮定して結論を得る方法である．このとき，結論のことを<ruby><dfn>帰結</dfn>
        <rt>consequence</rt>
      </ruby>という．演繹では使われた前提がすべて真であれば結論も真である．<ruby><dfn>帰納</dfn>
        <rt>induction</rt>
      </ruby>は前提からそれらしい一般的事実を導く方法である．結論が真とは限らないことに注意が必要である．また，言葉に帰納を含むが，対象をすべて網羅している場合である数学的帰納法などは演繹の一種である．しかし，数学の証明では演繹しか用いないので，演繹のことを単に推論といったり，数学的帰納法を単に帰納といったりもする．推論を次のように表す．
    </p>
    <dl>
      <h4>定義</h4>
      任意の前提の集合$\Gamma$，帰結$A$について，
      <dt>$\Gamma$から$A$への推論</dt>
      <dd>
        $$\Gamma\To A$$
      </dd>
    </dl>

    <h3>論理的帰結</h3>
    <p>
      意味論による定義で前提がすべて真であるとき，帰結が偽となりえない，または真となることが必然的であるとき，<ruby><dfn>論理的帰結</dfn>
        <rt>logical consequence</rt>
      </ruby>といい，次のように表す．
    </p>
    <dl>
      <h4>定義</h4>
      命題の集合$\Gamma$，命題$A$について，
      <dt>$\Gamma$から$A$への論理的帰結</dt>
      <dd>
        $$\Gamma\models A$$
      </dd>
    </dl>

    <h2>証明</h2>
    <h3>公理</h3>
    <p>
      推論では前提が真でなければ帰結が真であると言えない．このため，何かしらの命題を真であるとしないと何も始まらない，この命題を<ruby><dfn>公理</dfn>
        <rt>axiom</rt>
      </ruby>という．
    </p>

    <h3>推論規則</h3>
    <p>
      証明論では真偽の値を考えることをしない．そこで，どのような推論を許すかを定義することで真偽を定めずに帰結を判断できるようにした．この推論を<ruby><dfn>推論規則</dfn>
        <rt>inference rule</rt>
      </ruby>という．
    </p>

    <h3>証明体系</h3>
    <p>
      公理から推論規則を用いて新しい命題を推論していく．この公理と推論規則を定めた体系を<ruby><dfn>証明体系</dfn>
        <rt>proof system</rt>
      </ruby>という．公理と前提から推論規則で推論された命題を「前提から証明体系で<ruby><dfn>演繹可能</dfn>
        <rt>deducible</rt>
      </ruby>」という．公理を空の前提から演繹可能であるとする．このとき，空の前提から推論規則で推論された命題を「証明体系で<ruby><dfn>証明可能</dfn>
        <rt>proof system</rt>
      </ruby>」という．また，証明可能な命題を<ruby><dfn>定理</dfn>
        <rt>theorem</rt>
      </ruby>，定理への演繹を<ruby><dfn>証明</dfn>
        <rt>proof</rt>
      </ruby>という．前提のうち，公理や定理でないものを<ruby><dfn>仮定</dfn>
        <rt>assumption</rt>
      </ruby>という．これを次のように表す．
    </p>
    <dl>
      <h4>定義</h4>
      論理体系$\kappa$，命題の集合$\Gamma$，命題$A$について，
      <dt>$\kappa$で$\Gamma$から$A$は演繹可能</dt>
      <dd>
        $$\Gamma\vdash_\kappa A$$
      </dd>
      <dt>$\kappa$で$A$は証明可能</dt>
      <dd>
        $$\vdash_\kappa A$$
      </dd>
    </dl>
    <p>
      証明体系が明らかなときは体系名を省略して$\vdash$を用いてよい．また，$a_1,a_2,\cdots,a_n$の集合を$\set{a_1,a_2,\cdots,a_n}$と表すが，集合の本来の文字を用いると，認識しづらくなるので次の表現を使う．
    </p>
    <dl>
      <h4>定義</h4>
      命題の集合$\set{A_1,A_2,\cdots,A_n}$，命題$A$について，
      <dt>集合の省略</dt>
      <dd>
        $$A_1,A_2,\cdots,A_n\To A\Def\set{A_1,A_2,\cdots,A_n}\To A$$
        $$A_1,A_2,\cdots,A_n\models A\Def\set{A_1,A_2,\cdots,A_n}\models A$$
        $$A_1,A_2,\cdots,A_n\vdash A\Def\set{A_1,A_2,\cdots,A_n}\vdash A$$
      </dd>
    </dl>
    <p>
      また，これらを拡張した書き方も認めることとする．
    </p>
    <dl>
      <h4>定義</h4>
      命題の集合$A_1,A_2,\cdots,A_n,B_1,B_2,\cdots,B_n$について，
      <dt>$\To$記法の拡張</dt>
      <dd>
        「$A_1,A_2,\cdots,A_n\To B_1$」かつ「$A_1,A_2,\cdots,A_n\To B_2$」かつ$\cdots$かつ「$A_1,A_2,\cdots,A_n\To B_n$」なら，
        $$A_1,A_2,\cdots,A_n\To B_1,B_2,\cdots,B_n$$
        「$A_1,A_2,\cdots,A_n\To B_1,B_2,\cdots,B_n$」かつ「$B_1,B_2,\cdots,B_n\To B_1,B_2,\cdots,B_n$」のとき，
        $$A_1,A_2,\cdots,A_n\Iff B_1,B_2,\cdots,B_n$$
      </dd>
    </dl>

    <h2>命題定数</h2>
    <h3>トートロジー</h3>
    <p>
      <ruby><dfn>トートロジー</dfn>
        <rt>tautology</rt>
      </ruby>(<dfn>恒真命題</dfn>)とは意味論的には常に真である命題である．証明論的には証明された命題である．トートロジーを表す文字として次のを用いる．
    </p>
    <dl>
      <h4>定義</h4>
      <dt>トートロジー</dt>
      <dd>
        $$\top$$
      </dd>
    </dl>

    <h3>矛盾</h3>
    <p>
      <ruby><dfn>矛盾</dfn>
        <rt>contradiction</rt>
      </ruby>(<dfn>恒偽命題</dfn>)とは意味論的には常に偽である命題である．
    </p>
    <dl>
      <h4>定義</h4>
      <dt>矛盾</dt>
      <dd>
        $$\bot$$
      </dd>
    </dl>
    <div class="me">
      常に真とか偽とかそんな命題あるの？
    </div>
    <div class="you">
      例えば，$1=1$って真だし，$0=1$は偽だよね
    </div>
    <div class="me">
      でも，よく頭のいい人が$0=1$を証明してるよね
    </div>
    <div class="you">
      あれは間違った証明をネタでやってるものだから，信じてはいけないよ
    </div>
  </main>
  <footer>Copyright &copy; raygo All Rights Reserved since 2016.</footer>
</body>

</html>