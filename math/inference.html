<!DOCTYPE html>
<html lang="ja">

<head>
  <title>推論</title>
  <script src="../lib/main.js" defer></script>
</head>

<body>
  <header>
    <a href="../">ホーム</a> / <a href="./">数学</a> /
  </header>
  <main>
    これまで，一般的な1階述語論理について説明したが，ここからはよく使われる記法に限って説明する．
    <h2>定義</h2>
    <p>
      以前に定義の定義をしたが，数学を形式化するためには定義の形式化も必要である．そこで，次の表現を用いる．
    </p>
    <section class="def">
      <h4>論理式の定義</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        「$A$を$B$で定義する」とは
        $ A :<==> B $
      </p>
      <h4>項の定義</h4>
      <ul>
        <li>$a, b$: 項</li>
      </ul>
      <p>
        「$a$を$b$で定義する」とは
        $ a := b $
      </p>
    </section>
    <p>
      と表し，それぞれ次の述語が成り立つとする．
    </p>
    <section class="thm">
      <h4>論理式の定義の言い換え</h4>
      <ul>
        <li>$B$: 論理式</li>
        <li>$A$: $B$で定義された論理式</li>
      </ul>
      <p>
        $ A <==> B $
      </p>
      <h4>項の定義の言い換え</h4>
      <ul>
        <li>$b$: 項</li>
        <li>$a$: $b$で定義された項</li>
      </ul>
      <p>
        $ a = b $
      </p>
    </section>
    <p>
      この記号の定義は後ほど行う．
    </p>
    <p>
      $A, a$を<dfn>左辺</dfn>，$B, b$を<dfn>右辺</dfn>という．左辺と右辺の両方を<dfn>両辺</dfn>という．
    </p>
    <p>
      <dfn>等価</dfn>や<dfn>恒等</dfn>なことを<dfn>等しい</dfn>ともいう．等しい関係を<dfn>相等関係</dfn>といい，相等関係が満たすべき性質を<dfn>等価性</dfn>という．等価性については今後述べる．
    </p>
    <h2>1階述語論理で使われる文字</h2>
    <h3>真理関数</h3>
    <p>
      命題論理や1階述語論理で普通，構文論で具体的に用意される真理関数を次に示す．
    </p>
    <section class="def">
      <h4>否定</h4>
      <ul>
        <li>$A$: 論理式</li>
      </ul>
      <p>
        $ not (A) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$ではない
        </p>
      </details>
      <h4>連言</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ and (A, B) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$かつ$B$
        </p>
      </details>
      <h4>選言</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ or (A, B) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$または$B$
        </p>
      </details>
      <h4>含意</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ -> (A, B) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$ならば$B$
        </p>
      </details>
    </section>
    <p>
      このままでは扱いづらいので，真理関数を演算子として扱いたい．このとき，<dfn>論理演算子</dfn>ともいう．次のように表す．
    </p>
    <section class="def">
      <h4>$not$演算子</h4>
      <ul>
        <li>$A$: 論理式</li>
      </ul>
      <p>
        $ (not A) :<==> not(A) $
      </p>
      <h4>$and$演算子</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ (A and B) :<==> and (A, B) $
      </p>
      <h4>$or$演算子</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ (A or B) :<==> or (A, B) $
      </p>
      <h4>$->$演算子</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ (A -> B) :<==> -> (A, B) $
      </p>
    </section>

    <p>
      2項演算子におけるこの記法を<dfn>中置記法</dfn>という．一方，前に置く記法を<dfn>前置記法</dfn>[<dfn>ポーランド記法</dfn>]という．後ろに置く記法を<dfn>後置記法</dfn>[<dfn>逆ポーランド記法</dfn>]という．便利なのでこれらのほかにもう2つ演算子を定義する．
    </p>
    <section class="def">
      <h4>同値</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ (A <-> B) :<==> ((A -> B) and (B -> A)) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$と$B$は同値
        </p>
      </details>
      <h4>排他的論理和</h4>
      <ul>
        <li>$A, B$: 論理式</li>
      </ul>
      <p>
        $ (A or.bar B) :<==> (A and (not B) or (not A) and B) $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $A$と$B$はどちらか一方
        </p>
      </details>
    </section>

    <h3>量化子</h3>
    <section class="ex">
      <p>
        二次関数$f(x) = a x^2 + b x + c$が次の条件を満たす$a, b, c$の必要十分条件を求めよ．
      </p>
      <ol>
        <li>すべての$x$で$x > 0$を満たす．</li>
        <li>$x > 0$を満たす$x$が存在する．</li>
      </ol>
    </section>
    <p>
      2つの量化表現を導入する．量化子$lambda$は項$x$を用いて，$lambda x$と表すことで論理式に対して1項演算子を表す．
    </p>
    <section class="def">
      <h4>全称量化子</h4>
      <p>
        $ forall $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          任意の～に対して
        </p>
      </details>
      <h4>存在量化子</h4>
      <p>
        $ exists $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          ある～が存在して
        </p>
      </details>
    </section>
    <p>
      具体的には，論理式$F$に対して「すべての$x$について$F(x)$である」を$forall x(F(x))$と表し，<dfn>全称量化</dfn>という．また，「$F(x)$となる$x$が存在する」を$exists x (F(x))$と表し，<dfn>存在量化</dfn>という．
    </p>

    <h3>項と述語</h3>
    <p>
      一般的な数学において項は集合のみとし，述語には$in$と$=$を用いる．述語を演算子として扱うとき，<dfn>関係演算子</dfn>という．これも論理演算子と同様に中置記法で表す．詳しくは集合論で扱う．
    </p>

    <h2>省略</h2>
    <h3>演算子の優先順位</h3>
    <p>
      論理演算子を用いると，「$P$でないかつ$Q$のときのみ$P$ならば$P$または$Q$である」という曖昧で複雑な命題に対しても$((((not P) and Q) <-> P) -> (P or Q))$と命題同士の関係を明確に記述することが出来る．しかし，括弧が冗長で式が煩雑である．そこで，演算子に<dfn>優先順位</dfn>を定める．演算子の優先順位とは括弧がない場合に優先して計算される順番のことである．<dfn>右結合</dfn>は優先順位が同じときに，文の右側の演算子を優先することである．左側の場合は<dfn>左結合</dfn>である．
    </p>
    <section class="def">
      <h4>括弧の省略</h4>
      <p>
        $(a)$が演算子の引数ではないとき
        $ a :<==> (a) $
      </p>
      <h4>一項演算子についての省略</h4>
      <p>
        $a$の一項演算子$star$に対して
        $ star a :<==> (star a) $
      </p>
      <h4>二項演算子についての優先順位</h4>
      <p>
        $a, b, c$の二項演算子$star_1$が$star_2$より優先順位が高いとき
        $ a star_1 b star_2 c :<==> (a star_1 b) star_2 c $
        $ a star_2 b star_1 c :<==> a star_2 (b star_1 c) $
      </p>
      <h4>左結合</h4>
      <p>
        $a, b, c$の二項演算子$star$が左結合のとき
        $ a star b star c :<==> (a star b) star c $
      </p>
      <h4>右結合</h4>
      <p>
        $a, b, c$の二項演算子$star$が右結合のとき
        $ a star b star c :<==> a star (b star c) $
      </p>
    </section>
    <p>
      各種演算子ごとの大まかな優先順位を定める．推論文字($->, <==>, tack, tack.double$)の優先順位は最下位とする，算術演算とは($+, -, union$など)数字や集合など同士の演算子である．
    </p>
    <section class="def">
      <p>
        上から順に優先順位が高いとする．
      </p>
      <ul>
        <li>算術演算子</li>
        <li>関係演算子</li>
        <li>論理演算子</li>
      </ul>
    </section>
    <p>
      論理演算子について優先順位を定める．
    </p>
    <section class="def">
      <p>
        上から順に優先順位が高いとする．
      </p>
      <ul>
        <li>$not$(右)</li>
        <li>$and$(左)</li>
        <li>$or$(左)</li>
        <li>$->$(右)</li>
        <li>$<->$(左)</li>
      </ul>
    </section>

    <section class="ex">
      <p>
        命題$P, Q, R$に対して，次を満たす．
        $ not P and Q <==> (not P) and Q. $
        $ P and Q or Q and R <==> (P and Q) or (Q and R). $
        $ not not P <==> not (not P). $
        $ P -> Q -> R <==> P -> (Q -> R). $
        $ not (P or Q) and R <==> (not (P or Q)) and R. $
      </p>
    </section>
    <details>
      <summary>練習問題1</summary>
      <p>
        次の括弧が省略された命題に括弧をつけなさい．
      </p>
      <ol>
        <li>$not P and Q$</li>
        <li>$P and Q or R -> P or not Q and R$</li>
        <li>$P -> Q -> P <-> Q$</li>
      </ol>
      <details>
        <summary>解答</summary>
        <p>
          優先順位が高い演算子から括弧をくくる．
        </p>
        <ol>
          <li>$((not P) and Q)$</li>
          <li>$(((P and Q) or R) -> (P or ((not Q) and R)))$</li>
          <li>$((P -> (Q -> P)) <-> Q)$</li>
        </ol>
      </details>
    </details>
    <details>
      <summary>練習問題2</summary>
      <p>
        次の式が命題論理における論理式なことを示せ．ただし，$P, Q$は原子命題とする．
      </p>
      <ol>
        <li>$P -> P$</li>
        <li>$not P and Q$</li>
        <li>$P <-> P$</li>
      </ol>
      <details>
        <summary>解答</summary>
        <p>
          定義通り順に確認していけばよい．
        </p>
        <ol>
          <li>
            与式を変形する．
            $
            & P -> P,\
            <==> & -> (P, P).
            $
            $P$は原子命題より$P$は論理式である．$->$は二項真理関数で$P$は論理式より$-> (P, P)$は論理式である．したがって，$P -> P$は論理式である．
          </li>
          <li>
            与式を変形する．
            $
            & not P and Q,\
            <==> & ((not P) and Q),\
            <==> & and (not (P), Q).
            $
            $P$は原子命題より$P$は論理式である．$not$は一項真理関数で$P$は論理式より$not (P)$は論理式である．また，$Q$は原子命題より$Q$は論理式である．よって，$and$は二項真理関数で$not (P)$と$Q$は論理式より$and (not (P), Q)$は論理式である．したがって，$not P and Q$は論理式である．
          </li>
          <li>
            与式を変形する．
            $
            & P <-> P,\
            <==> & (P -> P) and (P -> P),\
            <==> & and (P -> P, P -> P).
            $
            (1)より$P -> P$は論理式である．$and$は二項真理関数で$P -> P$は論理式より$and (P -> P, P -> P)$は論理式である．したがって，$P <-> P$は論理式である．
          </li>
        </ol>
      </details>
    </details>

    <h3>量化子の省略</h3>
    <p>
      量化子は適用範囲を決める必要があり，その範囲を括弧で囲わなければならない．しかし，変項が増えると括弧が煩雑になってしまうため，省略を考える．他にも便利な記法として次のものを定める．
    </p>
    <section class="def">
      <h4>適用範囲の省略</h4>
      <p>
        量化子$lambda$，論理式$lambda x (A)$が演算子の引数ではないときについて
        $ lambda x, A :<==> lambda x (A) $
      </p>
      <h4>同量化の省略</h4>
      <p>
        量化子$lambda$について
        $ lambda x y (A) :<==> lambda x lambda y (A) $
      </p>
      <h4>量化子の別記</h4>
      <p>
        $ ""^lambda x, A :<==> lambda x, A $
      </p>
      <h4>$forall$の条件の省略</h4>
      <p>
        論理式$A$，述語$F$について
        $ forall F(x_1, dots, x_n) (A) :<==> forall x_1 dots.c x_n (F(x_1, dots, x_n) -> A) $
        $ forall F(x_1, dots, x_n) :<==> forall F(x_1, dots, x_n) (bot) $
      </p>
      <h4>$exists$の条件の省略</h4>
      <p>
        論理式$A$，述語$F$について
        $ exists F(x_1, dots, x_n) (A) :<==> exists x_1 dots.c x_n, (F(x_1, dots, x_n) and A) $
        $ exists F(x_1, dots, x_n) :<==> exists F(x_1, dots, x_n), top $
      </p>
      <h4>唯一存在量化子</h4>
      <p>
        述語$F$について
        $ exists! F(x) :<==> exists F(x) and forall F(x) F(y) (x = y) $
      </p>
    </section>

    <h3>否定の省略</h3>
    <p>
      否定した命題や述語はよく使われる．そのたびに，先頭に$not$をつけて括弧でくくっていては，冗長的で認識しづらい．量化子や関係演算子に斜線を入れることで否定を表現する．
    </p>
    <section class="def">
      <h4>量化子の否定</h4>
      <p>
        量化子$lambda$について
        $ cancel(lambda) x (A) :<==> not (lambda x (A)) $
      </p>
      <h4>関係演算子の否定</h4>
      <p>
        変数$x, y$の関係演算子$star$について
        $ x cancel(star) y :<==> not (x star y) $
      </p>
    </section>

    <h3>反転の省略</h3>
    <p>
      向きがある関係を表す演算子は表現力を上げるために逆向きで書くことがある．
    </p>
    <section class="def">
      <h4>反転記法</h4>
      <p>
        関係演算子$prec$に対して
        $ B succ A :<==> A prec B $
      </p>
    </section>

    <h2>推論</h2>
    <p>
      $A -> B$は重要な命題である．この命題が真のとき，$B$を$A$に対して<dfn>必要条件</dfn>，$A$を$B$に対して<dfn>十分条件</dfn>という．必要条件で十分条件のとき<dfn>必要十分条件</dfn>という．また，この命題の<dfn>逆</dfn>とは$B -> A$のことで，<dfn>裏</dfn>とは$not A -> not B$のことで，<dfn>対偶</dfn>とは$not B -> not A$のことである．これらの用語は証明の際にたびたび登場する．
    </p>

    <h3>演繹と帰納</h3>
    <p>
      <dfn>推論</dfn>とは<dfn>前提</dfn>から<dfn>結論</dfn>を論理的に導くことである．形式的には文の変形を意味する．推論には大きく2つに分かれており，演繹と帰納である．<dfn>演繹</dfn>は前提から結論を得る方法である．求めて得られた結論のことを<dfn>帰結</dfn>という．演繹では使われた前提がすべて真であれば結論も真である．<dfn>帰納</dfn>は前提から成り立ちそうな一般的事実を導くことである．結論が真とは限らないことに注意が必要である．言葉に帰納を含むが，数学的帰納法は演繹の一種である．推論を次のように表す．
    </p>
    <section class="def">
      <h4>推論</h4>
      <ul>
        <li>$Gamma$: 前提の集合</li>
        <li>$A$: 結論</li>
      </ul>
      <p>
        $ Gamma ==> A $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $Gamma$から$A$へ推論
        </p>
      </details>
    </section>
    <p>
      数学の証明では演繹しか用いないので，演繹のことを単に推論ともいったり，数学的帰納法を単に帰納法ともいったりする．
    </p>

    <h3>論理的帰結</h3>
    <p>
      意味論による定義で前提がすべて真のとき，帰結が偽となりえない，または真となることが必然的のとき，<dfn>論理的帰結</dfn>といい，次のように表す．
    </p>
    <section class="def">
      <h4>論理的帰結</h4>
      <ul>
        <li>$Gamma$: 命題の集合</li>
        <li>$A$: 命題</li>
      </ul>
      <p>
        $ Gamma tack.double A $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $Gamma$がすべて真のとき$A$が偽となりえない．
        </p>
      </details>
    </section>
    <p>
      論理体系によって定義が異なるので注意が必要である．
    </p>

    <h2>証明</h2>
    <h3>公理</h3>
    <p>
      推論では前提が真でなければ帰結が真と言えない．このため，何かしらの命題を真としないと何も推論することはできない．この命題を<dfn>公理</dfn>という．
    </p>

    <h3>推論規則</h3>
    <p>
      証明論では真偽の値を考えることをしない．そこで，どのような推論を許すかを定義することで真偽を定めずに帰結を判断できるようにした．この推論を<dfn>推論規則</dfn>という．
    </p>

    <h3>証明体系</h3>
    <p>
      公理から推論規則を用いて新しい命題を推論していく．この公理と推論規則を定めた体系を<dfn>証明体系</dfn>という．公理と前提から推論規則で推論された命題を<dfn>演繹可能</dfn>という．公理を空の前提から演繹可能とする．このとき，空の前提から推論規則で推論された命題を<dfn>証明可能</dfn>という．また，証明可能な命題を<dfn>定理</dfn>，定理への演繹を<dfn>証明</dfn>という．これを次のように表す．
    </p>
    <section class="def">
      <h4>演繹可能</h4>
      <ul>
        <li>$kappa$: 論理体系</li>
        <li>$Gamma$: 命題の集合</li>
        <li>$A$: 命題</li>
      </ul>
      <p>
        $ Gamma tack_kappa A $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $kappa$で$Gamma$から$A$へ導ける
        </p>
      </details>
      <h4>証明可能</h4>
      <ul>
        <li>$kappa$: 論理体系</li>
        <li>$A$: 命題</li>
      </ul>
      <p>
        $ tack_kappa A $
      </p>
      <details>
        <summary>読み</summary>
        <p>
          $kappa$で$A$は示された
        </p>
      </details>
    </section>
    <p>
      証明体系が明らかなときは体系名を省略して$tack$を用いてよい．また，$a_1, a_2, dots, a_n$の集合を${a_1, a_2, dots, a_n}$と表すが，集合の本来の文字を用いると，認識しづらくなるので次の表現を使う．
    </p>
    <section class="def">
      <h4>集合の省略</h4>
      <p>
        命題の集合${A_1, dots, A_n}$，命題$A$について
        $ (A_1, dots, A_n ==> A) :<==> ({A_1, dots, A_n} ==> A) $
        $ (A_1, dots, A_n tack.double A) :<==> ({A_1, dots, A_n} tack.double A) $
        $ (A_1, dots, A_n tack A) :<==> ({A_1, dots, A_n} tack A) $
      </p>
    </section>
    <p>
      また，これらを拡張した書き方も認めることとする．
    </p>
    <section class="def">
      <h4>$==>$記法の拡張</h4>
      <p>
        命題$A_1, dots, A_n, B_1, dots, B_n$について，
        「$A_1, dots, A_n ==> B_1$」または$dots.c$または「$A_1, dots, A_n ==> B_n$」のとき
        $ A_1, dots, A_n ==> B_1, dots, B_n $
        $==>$の前後が空のとき
        $ (==>) :<==> (top ==> bot) $
        「$A_1, A_2, dots, A_n ==> B_1, B_2, dots, B_n$」かつ「$B_1, B_2, dots, B_n ==> A_1, A_2, dots, A_n$」のとき
        $ A_1, A_2, dots, A_n <==> B_1, B_2, dots, B_n $
      </p>
    </section>

    <h3>関係式の省略</h3>
    <p>
      あまり好ましくないが，簡潔に表現するために次の省略を定義する．
    </p>
    <section class="def">
      <h4>関係式の拡張</h4>
      <p>
        $a, b, c$を引数にとる関係(推論文字，関係演算子)を表す記号$prec$について
        $ a prec b prec c :<==> a prec b and b prec c $
      </p>
    </section>

    <h2>命題定数</h2>
    <h3>トートロジー</h3>
    <p>
      <dfn>トートロジー</dfn>[<dfn>恒真命題</dfn>]とは意味論的には常に真な命題である．証明論的には証明された命題である．トートロジーを表す文字として次のを用いる．
    </p>
    <section class="def">
      <h4>トートロジー</h4>
      <p>
        $ top $
      </p>
    </section>

    <h3>矛盾</h3>
    <p>
      <dfn>矛盾</dfn>[<dfn>恒偽命題</dfn>]とは意味論的には常に偽な命題である．
    </p>
    <section class="def">
      <h4>矛盾</h4>
      <p>
        $ bot $
      </p>
    </section>
  </main>
</body>

</html>